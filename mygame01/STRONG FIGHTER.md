# STRONG FIGHTER
[![](<portfolio/● STRONG FIGHTER.md - Visual Studio Code 2025_01_21 14_24_42.png>)](https://youtu.be/2_j2-afy124)
プレイ動画
### 作成者
> 河原電子ビジネス専門学校 ゲームクリエイター科<br>
> 1年 谷本優樹

## 目次
>   - [1.作品概要](#1作品概要)
>   - [2.操作方法](#2操作方法)
>   - [3.ソースコード](#3ソースコード)
>   - [4.モード選択と〇側選択操作](#4モード選択と〇側選択操作)
>   - [技術紹介](#技術紹介)
>     - [5.自動振り向き](#5自動振り向き)
>     - [6.ステップ](#6ステップ)
>     - [7.敵CPU](#7敵cpu)
>     - [8.カメラ](#8カメラ)
>     - [9.制限時間のUI](#9制限時間のui)
>     - [10.KO時の演出](#10ko時の演出)
  
## 1.作品概要
> * ゲームジャンル
>   * 対戦型格闘ゲーム
> * プレイ人数
>   * 1～2人
> * 対応コントローラー
>   * Xbox 360 コントローラー
> * ゲーム内容
>   * 制限時間内に立ち回りを駆使しながら体力を減らすゲーム
> * ルール
>    * 制限時間: 99秒
>    * ラウンド数: 3
>    * 体力: 100
>    * 攻撃の種類は4種類(地上攻撃2種類、空中攻撃2種類)
> * 地上攻撃
>    * パンチ
>      * ダメージ: 5
>      * リーチ: 短
>      * 後隙: 短
>      * 発生: 短 
>    * キック
>      * ダメージ: 10
>      * リーチ: 長
>      * 後隙: 長
>      * 発生: 遅
> * 空中攻撃
>    * パンチ
>      * ダメージ: 5
>      * リーチ: 短
>      * 後隙: 長
>      * 発生: 短
>    * キック
>      * ダメージ: 5
>      * リーチ: 長
>      * 後隙: 長
>      * 発生: 短
> * ラウンド取得
>   * どちらかの体力が0になったら体力が残っている側がラウンドを取得できる
>   * 制限時間が過ぎたら体力が多い側がラウンドを取得できる
>   * お互いの体力が同時に0になったら引き分けになりお互いにラウンドを取得する
>   * 制限時間が過ぎてお互いの体力が同じの場合は引き分けとして扱いお互いにラウンドを取得する
> * 勝敗
>   * 先に2ラウンド先取したら勝利
>   * お互いに2ラウンド先取した場合は引き分けになる
> * 使用ツール
>   * Visual Studio 2022
>   * 3ds Max 2025
>   * Adobe Photoshop 2024
> * 使用言語
>   * C++
> * 開発環境
>   * Windows11
>   * 学校内製ゲームエンジン(DirectX12)
> * 開発期間
>   * 2024年9月~2025年1月
> * 制作人数
>   * 1人
>
> <br>
> 
> [目次へ戻る](#目次)

## 2.操作方法
> ![alt text](<portfolio/Game 2025-01-23 12-45-28_1.gif>)
> 移動: 左スティックの左右
>   
> ![alt text](<portfolio/Game 2025-01-23 12-45-28_2.gif>)
> ステップ: 左スティックの左右のどちらかを素早く2回倒す
> 
> ![alt text](<portfolio/Game 2025-01-23 12-45-28_3.gif>)
> ジャンプ: 左スティックを上に倒す
> 
> ![alt text](<portfolio/Game 2025-01-23 12-45-28_4.gif>)
> パンチ: Aボタン
> 
> ![alt text](<portfolio/Game 2025-01-23 12-45-28_5.gif>)
> キック: Bボタン
> 
> ![alt text](<portfolio/Game 2025-01-23 12-45-28_6.gif>)
> 空中パンチ: ジャンプ中にAボタン
> 
> ![alt text](<portfolio/Game 2025-01-23 12-45-28_7.gif>)
> 空中キック: ジャンプ中にBボタン
> 
> ![alt text](<portfolio/Game 2025-01-23 12-45-28_8.gif>)
> ![alt text](<portfolio/Game 2025-01-23 12-45-28_10.gif>)
> ![alt text](<portfolio/Game 2025-01-23 12-45-28_11.gif>)
> 上段ガード: 対応攻撃 ***パンチ***・***空中パンチ***・***空中キック***
> * プレイヤーが左側にいる場合は左スティックを左に倒す
> 
> ![alt text](<portfolio/Game 2025-01-23 12-45-28_9.gif>)
> 下段ガード: 対応攻撃 ***キック***
>   * プレイヤーが左側にいる場合は左スティックを左下に倒す
>
> <br>
> 
> [目次へ戻る](#目次)

## 3.ソースコード
<details>
<summary>
作成したソースコード
</summary>

> * BackGround.cpp
>   * BackGround.h
> * Debug.cpp
>   * Debug.h
> * Enemy.cpp
>   * Enemy.h
> * Fade.cpp
>   * Fade.h
> * Frame.cpp
>   * Frame.h
> * Game.cpp
>   * Game.h
> * GameCamera.cpp
>   * GameCamera.h
> * GameTimer.cpp
>   * GameTimer.h
> * HP.cpp
>   * HP.h
> * Player.cpp
>   * Player.h
> * Player2.cpp
>   * Player2.h
> * Result.cpp
>   * Result.h
> * Round.cpp
>   * Round.h
> * Title.cpp
>   * Title.h
</details>

<br>

[目次へ戻る](#目次)

## 4.モード選択と〇側選択操作
> ![alt text](<portfolio/Game 2025_01_21 14_24_54.png>)
> (図4.1) モード選択画面<br>
> <br>
> このゲームは2人対戦ができるのでモード選択する必要があります。(図4.1)<br>
> モード選択を選択したら次に〇側選択をします<br>
> ![alt text](<portfolio/Game 2025_01_23 8_33_40.png>)
> (図4.2) 1P VS CPUを選択したときの画面<br>
> <br>
> 
> ![alt text](<portfolio/Game 2025_01_23 8_33_50.png>)
> (図4.3) 1P VS 2Pを選択したときの画面<br>
> <br>
> 
> 〇側選択はラウンド開始時の初期位置を選択します。(図4.2) (図4.3)<br>
> ![alt text](<portfolio/Game 2025_01_23 8_34_59.png>)
> (図4.4) LEFTを選択した場合<br>
> <br>
> 
> ![alt text](<portfolio/Game 2025_01_23 8_35_18.png>)
> (図4.5) RIGHTを選択した場合<br>
> 
> [目次へ戻る](#目次)

# 技術紹介
## 5.自動振り向き
> ![alt text](<portfolio/Game 2025-01-23 12-45-28_12.gif>)
> プレイヤーと敵またはプレイヤー2のポジション(x軸)の値を使いif文を使用することで自動で方向を変えることができます。<br>
> 
> ![alt text](portfolio/image.png)
> (図5.1) プレイヤーが左方向を向くコード<br>
> <br>
> プレイヤーのポジションの値(x軸)が敵またはプレイヤー2のポジションの値(x軸)より大きかったら<br>
> プレイヤーは左方向を向きます。(図5.1)
> <br>
> 
> ![alt text](portfolio/image-1.png)
> (図5.2) プレイヤーが右を向くコード<br>
> <br>
> プレイヤーのポジションの値(x軸)が敵またはプレイヤー2のポジションの値(x軸)より小さかったら<br>
> プレイヤーは右方向を向きます。(図5.2)
> <br>
> 
> ![alt text](portfolio/image-4.png)<br>
> (図5.3) ジャンプしたときに方向を固定するコード<br>
> <br>
> ![alt text](portfolio/image-5.png)<br>
> (図5.4) 方向を固定しないコード<br>
> <br>
> ジャンプしているときは方向を変えずに今向いている方向を向くようにする。(図5.3)<br>
> 
> [目次へ戻る](#目次)
> 
> ## 6.ステップ
> 右ステップを例に説明すると<br>
> 
> ![alt text](portfolio/image-6.png)<br>
> (図6.1) 右ステップする前のコード<br>
> <br>
> 最初の左スティックを右に倒したときのコードは<br>
> 右に倒したどうかのフラグが立ったり、<br>
> どのくらい左スティックを右に倒しているかのフレームを計測してそのフレームを保管用変数に代入しています。(図6.1)<br>
> <br>
> 
> ![alt text](portfolio/image-7.png)<br>
> (図6.2) 左スティックを離したときのコード<br>
> <br>
> ![alt text](portfolio/image-8.png)<br>
> (図6.3) 右ステップ処理のコード<br>
> <br>
> 次に左スティックを離したときのコードは<br>
> さっき代入した保管用の変数を使って左スティックを右に倒していたフレームが10F(0.16秒)より短くて<br>
> 左スティックを離しているフレームが10F(0.16秒)経つまではステップフラグが立っています。(図6.2)<br>
> このフラグが立っているときに左スティックを右に倒したら右ステップすることができます。(図6.3)<br>
> 
> [目次へ戻る](#目次)

## 7.敵CPU
> 敵CPUは乱数で実装しました。<br>
> 移動とジャンプの処理を例に説明します。<br>
> 
> ### 距離
> ![alt text](portfolio/image-25.png)<br>
> (図7.1) 距離を求めるコード<br>
> <br>
> 行動処理するためにまずは敵からプレイヤーまでの距離を求める。(図7.1)<br>
> <br>
> 
> ### 移動処理<br>
> ![alt text](portfolio/image-26.png)<br>
> (図7.2) 移動処理のコード<br>
> <br>
> 移動処理は-1～1の範囲でランダムで値を出します。<br>
> 
> * -1が出たら左に移動する
> * 0が出たら立ち止まる
> * 1が出たら右に移動する<br>
> 
> 値を出したら乱数更新用フラグが立って時間が経つまで値を変えないようにする。<br>
> 時間が経過したらまたランダムで値を出せるようにする。(図7.2)<br>
> <br>
> 
> ### ジャンプ処理<br>
> ![alt text](portfolio/image-28.png)<br>
> (図7.3) 乱数処理のコード<br>
> <br>
> ![alt text](portfolio/image-30.png)<br>
> (図7.4) ジャンプ分岐処理のコード<br>
> <br>
> ![alt text](portfolio/image-31.png)<br>
> (図7.5) インターバル時間のコード<br>
> <br>
> ![alt text](portfolio/image-32.png)<br>
> (図7.6) 乱数の値をリセットするコード<br>
> <br>
> 
> 一定の距離まで近づいていたらジャンプするための処理をします。<br>
> ジャンプ処理は1~100の範囲でランダムで値を出します。(図7.3)<br>
> 
> * 1～49が出たらジャンプしない。<br>
> * 50～100が出たらジャンプ分岐処理をする。<br>
> 
> 値が出たら次に斜めジャンプするかどうかの処理をします。<br>
> 処理はさっきと同じで1~100の範囲でランダムで値を出します。(図7.4)<br>
> * 1~49が出たら垂直ジャンプする。<br>
> * 50~100が出たらプレイヤーの位置によって左斜めジャンプか右斜めジャンプする。<br>
> 
> ジャンプしたら乱数の値をリセットします。(図7.6)<br>
> ジャンプし終わったらさっきの移動処理と同じで時間が経つまで値を変えないようにして<br>
> 時間が経過したらまたランダムで値を出せるようにする。(図7.5)<br>
> 一定の距離まで近づいていなかったら乱数の値をリセットしてジャンプ処理を行わない。(図7.6)<br>
> <br>
> 
> ![alt text](portfolio/image-33.png)<br>
> (図7.7) ステップ処理のコード<br>
> <br>
> 残りの行動はステップ・地上攻撃・空中攻撃でこの処理も移動・ジャンプ処理と同じ要領で処理していますが<br>
> ステップのみプレイヤーの位置によって左ステップか右ステップします。(図7.7)<br>
> 
> [目次へ戻る](#目次)

## 8.カメラ
> ### 初期位置と現在位置の取得
> ![alt text](portfolio/image-15.png)<br>
> (図8.1) 初期位置を取得するコード<br>
> <br>
> ![alt text](portfolio/image-16.png)<br>
> (図8.2) 現在位置を取得するコード<br>
> <br>
> 視点と注視点・画面端の処理で必要なので初期位置(図8.1)と現在位置(図8.2)を取得する<br>
> <br>
> 
> ### 注視点の処理
> ![alt text](portfolio/image-18.png)<br>
> (図8.3) 注視点(x軸)の処理するコード<br>
> <br>
> ![alt text](portfolio/image-20.png)<br>
> (図8.4) 注視点(y軸・z軸)の処理するコード<br>
> <br>
> 
> 注視点は以下の式で実装しました。<br>
> * x軸:(プレイヤーと敵(プレイヤー2)の合計) / 2 = 注視点 (図8.3)<br>
> * y軸: (プレイヤーと敵(プレイヤー2)の合計) / 2 + 50.0f = 注視点 (図8.4)<br>
> * z軸: 今回は動かさないので0.0fに固定 (図8.4)<br>
> 
> ### 画面端の処理
> #### キャラクター
> ![alt text](portfolio/image-35.png)<br>
> (図8.5) Player.cpp:画面端判定処理<br>
> <br>
> ![alt text](portfolio/image-36.png)<br>
> (図8.6) Player.cpp:画面端に行っていないとき<br>
> <br>
> ![alt text](portfolio/image-37.png)<br>
> (図8.7) Player.cpp:画面端に行ったときの処理<br>
> <br>
> ![alt text](portfolio/image-17.png)<br>
> (図8.8) 画面端処理用のコード<br>
> * 画面端処理用の値を求める式
>   * 左側: ( |プレイヤーと敵(プレイヤー2)の初期位置の合計(x軸)| ) - ( プレイヤーと敵(プレイヤー2)の現在位置の差 )<br>
>   * 右側: ( |プレイヤーと敵(プレイヤー2)の初期位置の合計(x軸)| ) + ( プレイヤーと敵(プレイヤー2)の現在位置の差 )<br>
> <br>
> 
> このコードはプレイヤーが画面端に行ったときの処理が書かれているコードです。(図8.5) (図8.6) (図8.7) (図8.8)<br>
> 画面端に行く条件は2つあります。<br>
> * 左スティックを右または右上を倒した状態でGameCamera.cppのm_movePos.xの値が-100以下のとき (図8.8)
> * 左スティックを右または右上を倒した状態でプレイヤーの現在位置のx軸が-550.0fまたは550.0fに行ったとき
>
> この条件に当てはまったら画面端に行ったときの処理を行います。(図8.5)<br>
> 右画面端に行ったときを例に説明すると<br>
> 
> * 1つ目の条件に当てはまったらときは<br>
> 画面端に行っていないときに現在位置を画面端用の位置保管変数に更新し続けたものを<br>
> 現在位置を設定する関数にその変数を入れることでこれ以上右側に進まないようにすることができます。(図8.6) (図8.7)<br>
> 
> * 2つ目の条件に当てはまったときは<br>
> 右画面端の位置を現在位置を設定する関数に入れることでこれ以上右側に進まないようにすることができます。(図8.7)<br>
> <br>
> 
> #### カメラ
> ![alt text](portfolio/image-34.png)<br>
> (図8.9) 画面端到達判定用のコード<br>
> * 画面端到達判定用の値を求める式
>   * 左側: -200.0f + (プレイヤーと敵(プレイヤー2)の合計) / 2<br>
>   * 右側: 200.0f + (プレイヤーと敵(プレイヤー2)の合計) / 2<br>
> <br>
> 
> ![alt text](portfolio/image-19.png)
> <br>
> 画面端用に求めた値(図8.9)を使用してもし画面端に行ったら注視点(X軸)を固定する<br>
> 
> ![alt text](portfolio/image-21.png)
> <br>
> (図8.10)視点・注視点の設定<br>
> 
> [目次へ戻る](#目次)

## 9.制限時間のUI
> 学校内製ゲームエンジンにはテキストを表示する関数があります。<br>
> ![alt text](portfolio/image-13.png)<br>
> (図9.1) テキストを表示するコード<br>
> <br>
> これはデバッグ用に作ったコードです<br>
> このプログラムでUIを作らず簡単にテキスト表示することができます。(図9.1)<br>
> <br>
> 
> ![alt text](<portfolio/Game 2025_01_23 8_43_45.png>)<br>
> (図9.2) 制限時間の数字のUI<br>
> <br>
> ですが今回制作したゲームのUIは大体は自分で作りました。<br>
> その中の制限時間の数字のUI(図9.2)も作りそれをさっき説明したテキストを簡単に表示するコードを<br>
> 使うことできないので以下のコードを実装することで制限時間の数字のUIを表示することに成功しました。<br>
> 
> 実装したコードについて説明します。<br>
> ![alt text](portfolio/image-12.png)<br>
> (図9.3) GameTimer.hのメンバ変数<br>
> <br>
> ![alt text](portfolio/image-10.png)<br>
> (図9.4) 制限時間の数字2桁目のUIの設定<br>
> <br>
> ![alt text](portfolio/image-11.png)<br>
> (図9.5) 制限時間の数字1桁目のUIの設定<br>
> <br>
> 制限時間の数字のUI表示するためにSpriteRender型というのを使います<br>
> SpriteRenderは画像を表示するために使います。<br>
> 今回はSpriteRenderの変数を配列にして2つ宣言します。(図9.3)<br>
> <br>
> 
> ### 制限時間の処理<br>
> ![alt text](portfolio/image-9.png)<br>
> (図9.6) 制限時間の処理をするコード<br>
> <br>
> ラウンドが終わっていなかったら制限時間は進んでいきます。<br>
> 制限時間の数字1桁と2桁の求め方を説明していきます。(図9.6)<br>
> * 2桁目<br>
> 制限時間の値を10で割ることで制限時間の数字2桁目が求まることができます。<br>
> * 1桁目<br>
> 制限時間を10で割ってからさっき求めた2桁目の値を引いてから10を掛けると制限時間の1桁目が求まることができます。<br>
> 
> 整数値に変換するのは制限時間の数字を表示するための変数は配列にしています。<br>
> この配列の要素数(0~9)の値は整数値です。<br>
> さっき求めた1桁目と2桁目の値は実数値でこれを配列の要素数に適用して表示したいので整数値に変換する必要があります。<br>
> <br>
> 
> ![alt text](portfolio/image-14.png)<br>
> (図9.7) 制限時間の数字のUI描画<br>
> 
> [目次へ戻る](#目次)

## 10.KO時の演出
> ![alt text](<portfolio/Game 2025-01-23 12-45-28.gif>)
> <br>
> 地上で攻撃を当てた場合<br>
> 
> ![alt text](<portfolio/Game 2025-01-23 12-45-28_13.gif>)
> <br>
> 空中で攻撃を当てた場合<br>
> 
> ### 時が止まっている演出
> ![alt text](portfolio/image-22.png)<br>
> (図10.1) アニメーション再生速度<br>
> <br>
> KOが表示しているときに時を止まっているように見せるように<br>
> 各キャラクターのアニメーション再生速度を0.0fに設定すれば<br>
> 時が止まっているように見せることができる。(図10.1)<br>
> <br>
> 
> ### 空中で攻撃が当たった場合
> ![alt text](portfolio/image-23.png)<br>
> (図10.2) ラウンドが終わったときに空中にいたときのコード<br>
> <br>
> もしジャンプしているときに体力が0になったときはKOが表示している間は落下しないようにして<br>
> KOが表示しなくなったら落下するようにする。(図10.2)<br>
> <br>
> 
> ### 勝利アニメーションからフェードイン
> ![alt text](portfolio/image-24.png)<br>
> (図10.3) ラウンドが終わったときに攻撃・負けアニメーションが再生していないときのコード<br>
> <br>
> KOが表示しなくなったら勝った側は攻撃アニメーションを最後まで再生して<br>
> 負けた側は負けアニメーションを再生して<br>
> 負けアニメーションの再生が終わったら勝った側は勝利アニメーションを再生して<br>
> 再生が終わったら次のラウンドに行くためフェードアウトするか2ラウンド取得したらリザルト画面を表示する。(図10.3)<br><br>
> 
> [目次へ戻る](#目次)